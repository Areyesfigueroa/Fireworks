<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.js canvas - particles - sprites</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable = no, minimum-scale=1.0, maximum-scale=1.0">

  <style>
    body
    {
      background-color: #000000;
      margin: 0px;
      overflow: hidden;
    }

    canvas
    {
      color: #0078ff;
    }

  </style>
</head>
<body>

  <!--Initializing Canvas-->
  <canvas id="myCanvas"></canvas>

  <!--Loading Three.js Library-->
  <script src="three.js"></script>
  <script src="particle.js"></script>
  <script src="firework.js"></script>

  <!--Creating Renderer. NOTE: renderer helps draw everything into our canvas-->
  <script>

    //global variables
    var camera, scene, renderer;
    var ambientLight, pointLight;
    var geometry, material, mesh;

    //Particles, 2D
    var fireworks = []; //make an array.


    //Animation
    var deltaTime = 1;

    //Init Call
    init();
    animate();

    function init()
    {
      //RENDERER
      //Renderer Draws onto the canvas.

      //renderer properties.
      renderer.setClearColor(000000); //Black
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      //CAMERA
      //params(fieldOfView, aspect ratio, clipping range)
      camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 3000);

      //SCENE
      //Create a new instance of THREE.Scene.
      scene = new THREE.Scene();

      //LIGHTS
      //params (color, intensity)
      ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);  //Add ambientLight to the scene

      pointLight = new THREE.PointLight(0xffffff, 0.5);
      scene.add(pointLight);  //Add point light to the scene.


      //scene.add(mesh);//Add our mesh to the scene


      /*REFERENCES
       Method 1:
      params(x = 100, y = 100, z = 100)
      var geometry = new THREE.BoxGeometry(100, 100, 100);

      Method 2:
      var geometry = new THREE.Geometry();
      //add vertices by pushing them into the vertices array.
      geometry.vertices.push(
        new THREE.Vector3(-10, 10, 0),
        new THREE.Vector3(-10, -10, 0),
        new THREE.Vector3(10, -10, 0)
      );
      //create the faces by pushing them into the faces array.
      //params(x, y, z)
      geometry.faces.push(new THREE.Face3(0, 1, 2));

      Method 3: Static geometry. Saves on performance
      var geometry = new THREE.BufferGeometry();
      var vertices = new Float32Array([
        -10.0, -10.0, 0.0,
        10.0, -10.0, 0.0,
        10.0, 10.0, 0.0
      ]);
      //add its position
      geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));


      //DIFFERENT TYPES OF GEOMETRY
      //params(width, height)
      //var geometry = new THREE.PlaneGeometry(100, 100);
      //params(radius, subdivisionWidth(optional), subdivisionHeight(optional))
      //var geometry = new THREE.SphereGeometry(50, 50, 50);
      //params(x, y, z)
      //var geometry = new THREE.CircleGeometry(50, 50, 50);
      //params(radius, subdivisionWidth, subdivisionHeight)
      //var geometry = new THREsE.ConeGeometry(50, 50, 50);
      // And many more....
      */
    }

    function animate()
    {
      //If Random number between 0 and 1 is < 0.1 -> 5% chance of making a firework.
      if(Math.random() * 1 < 0.04)
      {
        //PARTICLE
        fireworks.push(new Firework()); //Array of particles.
      }

      for(var i= fireworks.length - 1; i >= 0; i--)
      {
        fireworks[i].update();
        fireworks[i].show();

        //if firework is done
        if(fireworks[i].done())
        {
          fireworks.splice(i, 1);
        }
      }

      console.log(fireworks.length);

      //RENDER CALL
      render();
      requestAnimationFrame(animate);
    }

    //Draw Function
    function render()
    {
      //Render whole scene.
      renderer.render(scene, camera);
    }

  </script>

</body>

</html>
